#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

#include "kyk_sha.h"
#include "kyk_ecdsa.h"
#include "kyk_utils.h"
#include "kyk_buff.h"
#include "mu_unit.h"

char *test_ec_get_pubkey_from_priv()
{

    uint8_t priv_bytes[32] = {
	0x18,0xE1,0x4A,0x7B,0x6A,0x30,0x7F,0x42,
	0x6A,0x94,0xF8,0x11,0x47,0x01,0xE7,0xC8,
	0xE7,0x74,0xE7,0xF9,0xA4,0x7E,0x2C,0x20,
	0x35,0xDB,0x29,0xA2,0x06,0x32,0x17,0x25
    };

    char *err_msg = "Failed to test ecdsa";
    
    /* uncompressed pubkey */
    uint8_t target_pub1[65] = {
	0x04, 0x50, 0x86, 0x3a, 0xd6, 0x4a, 0x87, 0xae,
	0x8a, 0x2f, 0xe8, 0x3c, 0x1a, 0xf1, 0xa8, 0x40,
	0x3c, 0xb5, 0x3f, 0x53, 0xe4, 0x86, 0xd8, 0x51,
	0x1d, 0xad, 0x8a, 0x04, 0x88, 0x7e, 0x5b, 0x23,
	0x52, 0x2c, 0xd4, 0x70, 0x24, 0x34, 0x53, 0xa2,
	0x99, 0xfa, 0x9e, 0x77, 0x23, 0x77, 0x16, 0x10,
	0x3a, 0xbc, 0x11, 0xa1, 0xdf, 0x38, 0x85, 0x5e,
	0xd6, 0xf2, 0xee, 0x18, 0x7e, 0x9c, 0x58, 0x2b,
	0xa6
    };
    

    /* compressed pubkey */
    uint8_t target_pub2[33] = {
	0x02, 0x50, 0x86, 0x3a, 0xd6, 0x4a, 0x87, 0xae,
	0x8a, 0x2f, 0xe8, 0x3c, 0x1a, 0xf1, 0xa8, 0x40,
	0x3c, 0xb5, 0x3f, 0x53, 0xe4, 0x86, 0xd8, 0x51,
	0x1d, 0xad, 0x8a, 0x04, 0x88, 0x7e, 0x5b, 0x23,
	0x52
    };

    struct kyk_buff* pub1;
    struct kyk_buff* pub2;

    int res = -1;

    res = kyk_ec_get_pubkey_from_priv(priv_bytes, 0, &pub1);
    check(res == 0, "failed to kyk_ec_get_pubkey_from_priv");
    mu_assert(kyk_digest_eq(pub1 -> base, target_pub1, pub1 -> len), "failed to get the correct uncompressed pub");
    
    res = kyk_ec_get_pubkey_from_priv(priv_bytes, 1, &pub2);
    check(res == 0, "failed to kyk_ec_get_pubkey_from_priv");
    mu_assert(kyk_digest_eq(pub2 -> base, target_pub2, pub2 -> len), "failed to get the correct compressed pub");

    return NULL;
    
error:
    return err_msg;
}

char* test_kyk_ec_sign()
{

    uint8_t priv_bytes[32] = {
	0x18,0xE1,0x4A,0x7B,0x6A,0x30,0x7F,0x42,
	0x6A,0x94,0xF8,0x11,0x47,0x01,0xE7,0xC8,
	0xE7,0x74,0xE7,0xF9,0xA4,0x7E,0x2C,0x20,
	0x35,0xDB,0x29,0xA2,0x06,0x32,0x17,0x25
    };
    
    const char message[] = "Hello Bitcoin";
    char* errmsg = "Failed to test_kyk_ec_sign";

    uint8_t digest[32];
    struct kyk_buff* der = NULL;
    int res = -1;
    
    kyk_dgst_sha256(digest, (uint8_t *)message, strlen(message));

    res = kyk_ec_sign(priv_bytes, digest, sizeof(digest), &der);
    check(res == 0, "failed to kyk_ec_sign");

    free_kyk_buff(der);

    return NULL;

error:

    return errmsg;
}

char* test_kyk_ec_sign_hash256()
{

    uint8_t priv_bytes[32] = {
	0x18,0xE1,0x4A,0x7B,0x6A,0x30,0x7F,0x42,
	0x6A,0x94,0xF8,0x11,0x47,0x01,0xE7,0xC8,
	0xE7,0x74,0xE7,0xF9,0xA4,0x7E,0x2C,0x20,
	0x35,0xDB,0x29,0xA2,0x06,0x32,0x17,0x25
    };
    
    /* compressed pubkey */
    uint8_t pubkey[33] = {
	0x02, 0x50, 0x86, 0x3a, 0xd6, 0x4a, 0x87, 0xae,
	0x8a, 0x2f, 0xe8, 0x3c, 0x1a, 0xf1, 0xa8, 0x40,
	0x3c, 0xb5, 0x3f, 0x53, 0xe4, 0x86, 0xd8, 0x51,
	0x1d, 0xad, 0x8a, 0x04, 0x88, 0x7e, 0x5b, 0x23,
	0x52
    };

    uint8_t* sig_buf = NULL;
    size_t sig_buf_len = 0;

    int res = -1;

    const char message[] = "Hello Hello Bitcoin";

    res = kyk_ec_sign_hash256(priv_bytes, (uint8_t*)message, strlen(message), &sig_buf, &sig_buf_len);
    mu_assert(res == 0, "Failed to test_kyk_ec_sign_hash256");

    res = kyk_ec_sig_hash256_verify((uint8_t*)message, strlen(message),
				    sig_buf, sig_buf_len,
				    pubkey, sizeof(pubkey));
    
    check(res == 1, "Failed to test_kyk_ec_sign_hash256: kyk_ec_sig_hash256_verify failed");

    return NULL;

error:

    return "Failed to test_kyk_es_sign_hash256";

}

char* test_kyk_ec_sig_verify()
{
    /* uint8_t priv_bytes[32] = { */
    /* 	0x18,0xE1,0x4A,0x7B,0x6A,0x30,0x7F,0x42, */
    /* 	0x6A,0x94,0xF8,0x11,0x47,0x01,0xE7,0xC8, */
    /* 	0xE7,0x74,0xE7,0xF9,0xA4,0x7E,0x2C,0x20, */
    /* 	0x35,0xDB,0x29,0xA2,0x06,0x32,0x17,0x25 */
    /* }; */

    uint8_t der[72] = {
	0x30, 0x45, 0x02, 0x20, 0x27, 0x98, 0x42, 0xe9,
	0xe2, 0xe0, 0x55, 0x66, 0x80, 0x00, 0x6f, 0x03,
	0xd9, 0x1b, 0x89, 0x27, 0xbe, 0xb4, 0xe0, 0x5d,
	0x74, 0x76, 0xda, 0xd1, 0x5d, 0x1a, 0x74, 0xec,
	0xbf, 0x37, 0x13, 0x59, 0x02, 0x21, 0x00, 0xc3,
	0x27, 0x72, 0x67, 0x4c, 0x2c, 0x77, 0xbe, 0x4e,
	0x6a, 0x67, 0x51, 0x21, 0xaf, 0xe7, 0xc8, 0x73,
	0x23, 0xb1, 0xf4, 0xae, 0xa5, 0xf2, 0xd5, 0x69,
	0x90, 0xad, 0xba, 0x46, 0x8f, 0xcc, 0x68, 0x00
    };
    
    uint8_t pub1[65] = {
	0x04, 0x50, 0x86, 0x3a, 0xd6, 0x4a, 0x87, 0xae,
	0x8a, 0x2f, 0xe8, 0x3c, 0x1a, 0xf1, 0xa8, 0x40,
	0x3c, 0xb5, 0x3f, 0x53, 0xe4, 0x86, 0xd8, 0x51,
	0x1d, 0xad, 0x8a, 0x04, 0x88, 0x7e, 0x5b, 0x23,
	0x52, 0x2c, 0xd4, 0x70, 0x24, 0x34, 0x53, 0xa2,
	0x99, 0xfa, 0x9e, 0x77, 0x23, 0x77, 0x16, 0x10,
	0x3a, 0xbc, 0x11, 0xa1, 0xdf, 0x38, 0x85, 0x5e,
	0xd6, 0xf2, 0xee, 0x18, 0x7e, 0x9c, 0x58, 0x2b,
	0xa6
    };

    /* compressed pubkey */
    uint8_t pub2[33] = {
	0x02, 0x50, 0x86, 0x3a, 0xd6, 0x4a, 0x87, 0xae,
	0x8a, 0x2f, 0xe8, 0x3c, 0x1a, 0xf1, 0xa8, 0x40,
	0x3c, 0xb5, 0x3f, 0x53, 0xe4, 0x86, 0xd8, 0x51,
	0x1d, 0xad, 0x8a, 0x04, 0x88, 0x7e, 0x5b, 0x23,
	0x52
    };
    
    const char message[] = "Hello Bitcoin";
    uint8_t digest[32];
    int res = -1;
        
    kyk_dgst_sha256(digest, (uint8_t *)message, strlen(message));

    res = kyk_ec_sig_verify(digest, sizeof(digest), der, sizeof(der), pub1, sizeof(pub1));
    mu_assert(res == 1, "failed to kyk_ec_sig_verify with uncompressed pubkey");

    res = kyk_ec_sig_verify(digest, sizeof(digest), der, sizeof(der), pub2, sizeof(pub2));
    mu_assert(res == 1, "failed to kyk_ec_sig_verify with compressed pubkey");

    return NULL;

}

char *all_tests()
{
    mu_suite_start();
    
    mu_run_test(test_ec_get_pubkey_from_priv);
    mu_run_test(test_kyk_ec_sign);
    mu_run_test(test_kyk_ec_sig_verify);
    mu_run_test(test_kyk_ec_sign_hash256);
    
    return NULL;
}

MU_RUN_TESTS(all_tests);

